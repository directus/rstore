<script setup>
import FrameworkBadges from './components/FrameworkBadges.vue'
</script>

# 0.6 to 0.7 Migration Guide

## Store setup

### `models` renamed to `schema`

<FrameworkBadges
  :frameworks="{
    vue: true,
    nuxt: false,
  }"
/>

::: info Why this change?
Since it now contains both models and relations (see below) - and maybe other objects in the future, the `models` option has been renamed to `schema`.
:::

```ts
const store = await createStore({
  models: [ // [!code --]
  schema: [ // [!code ++]
    { name: 'todos' },
    { name: 'users' },
  ],
  plugins: [],
})
```

### Use the RstorePlugin

<FrameworkBadges
  :frameworks="{
    vue: true,
    nuxt: false,
  }"
/>

You should now use the `RstorePlugin` from `@rstore/vue` to install the store in your Vue app. This will automatically provide the store to all components and make it available via the new `useStore` function from `@rstore/vue`.

::: info Why this change?
This change simplifies the store setup and makes it easier to use the store in your components. It also makes it possible to use the new `useStore` function from `@rstore/vue` directly without having to create your own.
:::

```ts
import type { VueStore } from '@rstore/vue'
import type { InjectionKey } from 'vue' // [!code --]
import { RstorePlugin } from '@rstore/vue' // [!code ++]

const injectStoreKey = Symbol('rstore') as InjectionKey<VueStore<typeof schema>> // [!code --]

export async function rstore(app: App) {
  const store = await createStore({
    // ...
  })

  app.provide(injectStoreKey, store) // [!code --]
  app.use(RstorePlugin, { store })  // [!code ++]
}

export function useStore () { // [!code --]
  const store = inject(injectStoreKey, null) // [!code --]
  if (store == null) { // [!code --]
    throw new Error('No rstore provided.') // [!code --]
  } // [!code --]
  return store // [!code --]
} // [!code --]

// Augment the `useStore` type
declare module '@rstore/vue' { // [!code ++]
  export function useStore(): VueStore<typeof schema> // [!code ++]
} // [!code ++]
```

### useStore()

<FrameworkBadges
  :frameworks="{
    vue: true,
    nuxt: false,
  }"
/>

You can now use the new `useStore` function from `@rstore/vue` directly instead of creating your own.

::: info Why this change?
This change simplifies the store usage in your components and makes it easier to get the store instance without having to create your own `useStore` function.
:::

```ts
import { useStore } from 'your-own-path/rstore' // [!code --]
import { useStore } from '@rstore/vue' // [!code ++]
```

### Relation definitions shape changed

<FrameworkBadges
  :frameworks="{
    vue: true,
    nuxt: true,
  }"
/>

Instead of defining the related fields using `on` and `eq` that were confusing, you now define the related fields using an `on` object that maps the foreign fields to the local fields with the name of the models to make it clearer.

::: info Why this change?
This new syntax is more explicit and easier to understand. It also allows for more complex relations such as mapping multiple fields or using a custom filter function.
:::

```ts
import { defineItemType } from '@rstore/vue'

interface User {
  id: string
  name: string
}

const userModel = defineItemType<User>().model({
  name: 'users',
  relations: {
    receivedMessages: {
      to: {
        messages: {
          on: 'recipientId', // [!code --] Message.recipientId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'messages.recipientId': 'users.id', // [!code ++]
          }, // [!code ++]
        },
      },
      many: true,
    },
    sentMessages: {
      to: {
        messages: {
          on: 'senderId', // [!code --] Message.senderId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'messages.senderId': 'users.id', // [!code ++]
          }, // [!code ++]
        },
      },
      many: true,
    },
  },
})

interface Message {
  id: string
  content: string
  senderId: string
  recipientId: string
}

const messageModel = defineItemType<Message>().model({
  name: 'messages',
  relations: {
    sender: {
      to: {
        users: {
          on: 'senderId', // [!code --] Message.senderId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'users.id': 'messages.senderId', // [!code ++]
          }, // [!code ++]
        },
      },
    },
    recipient: {
      to: {
        users: {
          on: 'recipientId', // [!code --] Message.recipientId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'users.id': 'messages.recipientId', // [!code ++]
          }, // [!code ++]
        },
      },
    },
  },
})
```

This new syntax also allows you to map multiple fields on a single relation:

```ts
const myModel = {
  name: 'things',
  relations: {
    relatedItems: {
      to: {
        otherModel: {
          on: {
            'otherModel.type': 'things.relatedItemType', // [!code ++]
            'otherModel.subType': 'things.relatedItemSubType', // [!code ++]
          },
        },
      },
    },
  },
}
```

Or specify a custom filter function:

```ts
const myModel = {
  name: 'things',
  relations: {
    relatedItems: {
      to: {
        otherModel: {
          on: {
            // 'otherModel.type': 'things.relatedItemType',
          },
          filter: (item, relationItem) => // [!code ++]
            item.relatedStatusList.includes(relationItem.status), // [!code ++]
        },
      },
    },
  },
}
```

If you use TypeScript, it is now recommended to use the new `defineRelations` helper to define your relations with proper typing:

```ts
import type { StoreSchema } from '@rstore/vue'
import { defineItemType, defineRelations } from '@rstore/vue'

interface User {
  id: string
  name: string
}

const userModel = defineItemType<User>().model({
  name: 'users',
})

interface Message {
  id: string
  content: string
  senderId: string
  recipientId: string
}

const messageModel = defineItemType<Message>().model({
  name: 'messages',
})

const userRelations = defineRelations(userModel, ({ model }) => ({
  receivedMessages: {
    to: model(messageModel, {
      on: {
        'messages.recipientId': 'users.id', // Type checked!
      },
    }),
    many: true,
  },
  sentMessages: {
    to: model(messageModel, {
      on: {
        'messages.senderId': 'users.id', // Type checked!
      },
    }),
    many: true,
  },
}))

const messageRelations = defineRelations(messageModel, ({ model }) => ({
  sender: {
    to: model(userModel, {
      on: {
        'users.id': 'messages.senderId', // Type checked!
      },
    }),
  },
  recipient: {
    to: model(userModel, {
      on: {
        'users.id': 'messages.recipientId', // Type checked!
      },
    }),
  },
}))

export const schema = [
  userModel,
  messageModel,
  userRelations,
  messageRelations,
] as const satisfies StoreSchema
```

Example of the typechecking in action:

![Typechecking example](./img/relation-typing.png)

## Query

### Methods don't accept Ref or getter anymore

<FrameworkBadges
  :frameworks="{
    vue: true,
    nuxt: true,
  }"
/>

The following methods no longer accept a Ref or a getter function as argument. You must now always pass a plain object (or string/number for single key):

- `peekFirst`
- `peekMany`
- `findFirst`
- `findMany`

```ts
store.User.peekFirst(() => 'toto') // [!code --]
store.User.peekFirst('toto') // [!code ++]

store.User.peekFirst(userIdRef) // [!code --]
store.User.peekFirst(userIdRef.value) // [!code ++]
```

::: info Why this change?
This change was made to simplify the API and avoid confusion. Those methods are not reactive and will not update automatically when the Ref or the result of the getter function changes. If you want to use a Ref or a getter function, you can use the `query` or `liveQuery` methods instead.
:::

### New Query API

<FrameworkBadges
  :frameworks="{
    vue: true,
    nuxt: true,
  }"
/>

The following methods have been removed:

- `queryFirst`
- `queryMany`
- `liveQueryFirst`
- `liveQueryMany`

They have been replaced by the following methods:

- `query`
- `liveQuery`

Those two new methods accept a function that receives a query builder as argument. You can then use the `first` or `many` methods of the query builder to build your query.

::: info Why this change?
This new syntax allows TypeScript to fully type check the entire options object, including verifying for excess properties in deeply nested objects. The old syntax was not type checked properly and your code could easily contain typos or mistakes that would not be caught by the compiler. This is due to a limitation in TypeScript (see [microsoft/TypeScript#241](https://github.com/microsoft/TypeScript/issues/241)).
:::

```ts
const { data: user } = await store.User.queryFirst('toto') // [!code --]
const { data: user } = await store.User.query(q => q.first('toto')) // [!code ++]
```

```ts
const { data: user } = await store.User.queryFirst(() => ({ // [!code --]
const { data: user } = await store.User.query(q => q.first({ // [!code ++]
  key: userId.value,
  include: { receivedMessages: true },
}))
```

```ts
const { data: messages } = await store.Message.queryMany(() => ({ // [!code --]
const { data: messages } = await store.Message.query(q => q.many({ // [!code ++]
  filter: m => m.recipientId === userId.value,
}))
```

```ts
const { data: messages } = await store.Message.liveQueryMany(() => ({ // [!code --]
const { data: messages } = await store.Message.liveQuery(q => q.many({ // [!code ++]
  filter: m => m.recipientId === userId.value,
}))
```

::: warning
Since the type checking is now stricter, you might encounter new type errors in your code that you didn't have before. This means that your code was not fully correct and you should fix the errors. If somethig looks wrong, please [open an issue](https://github.com/directus/rstore/issues/new?template=bug-report.yml). :pray:
:::

### Subscribe method now accepts query builder

<FrameworkBadges
  :frameworks="{
    vue: true,
    nuxt: true,
  }"
/>

The `subscribe` method now only accepts a function that receives a query builder as argument. You then have to call the query builder function with the options object.

```ts
const { unsubscribe } = store.Message.subscribe({ // [!code --]
const { unsubscribe } = store.Message.subscribe(q => q({ // [!code ++]
  params: {
    recipientId: 'user-123',
  },
}) // [!code --]
})) // [!code ++]
```

```ts
const { unsubscribe } = store.Message.subscribe(() => ({ // [!code --]
const { unsubscribe } = store.Message.subscribe(q => q({ // [!code ++]
  params: {
    recipientId: userId.value,
  },
}))
```

::: info Why this change?
This new syntax allows TypeScript to fully type check the entire options object, including verifying for excess properties in deeply nested objects. The old syntax was not type checked properly and your code could easily contain typos or mistakes that would not be caught by the compiler. This is due to a limitation in TypeScript (see [microsoft/TypeScript#241](https://github.com/microsoft/TypeScript/issues/241)).
:::

::: warning
Since the type checking is now stricter, you might encounter new type errors in your code that you didn't have before. This means that your code was not fully correct and you should fix the errors. If somethig looks wrong, please [open an issue](https://github.com/directus/rstore/issues/new?template=bug-report.yml). :pray:
:::
