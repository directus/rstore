# 0.6 to 0.7 Migration Guide

## Store constructor changes

### `models` renamed to `schema`

Since it now contains both models and relations (see below) - and maybe other objects in the future, the `models` option has been renamed to `schema`.

Before:

```ts
const store = await createStore({
  models: [ // [!code --]
    { name: 'todos' },
    { name: 'users' },
  ],
  plugins: [],
})
```

After:

```ts
const store = await createStore({
  schema: [ // [!code ++]
    { name: 'todos' },
    { name: 'users' },
  ],
  plugins: [],
})
```

## Relations

### Relation definitions shape changed

Instead of defining the related fields using `on` and `eq` that were confusing, you now define the related fields using an `on` object that maps the foreign fields to the local fields with the name of the models to make it clearer.

Before:

```ts
import { defineItemType } from '@rstore/vue'

interface User {
  id: string
  name: string
}

const userModel = defineItemType<User>().model({
  name: 'users',
  relations: {
    receivedMessages: {
      to: {
        messages: {
          on: 'recipientId', // [!code --] Message.recipientId
          eq: 'id', // [!code --] User.id
        },
      },
      many: true,
    },
    sentMessages: {
      to: {
        messages: {
          on: 'senderId', // [!code --] Message.senderId
          eq: 'id', // [!code --] User.id
        },
      },
      many: true,
    },
  },
})

interface Message {
  id: string
  content: string
  senderId: string
  recipientId: string
}

const messageModel = defineItemType<Message>().model({
  name: 'messages',
  relations: {
    sender: {
      to: {
        users: {
          on: 'senderId', // [!code --] Message.senderId
          eq: 'id', // [!code --] User.id
        },
      },
    },
    recipient: {
      to: {
        users: {
          on: 'recipientId', // [!code --] Message.recipientId
          eq: 'id', // [!code --] User.id
        },
      },
    },
  },
})
```

After:

```ts
import { defineItemType } from '@rstore/vue'

interface User {
  id: string
  name: string
}

const userModel = defineItemType<User>().model({
  name: 'users',
  relations: {
    receivedMessages: {
      to: {
        messages: {
          on: { // [!code ++]
            'messages.recipientId': 'users.id', // [!code ++]
          }, // [!code ++]
        },
      },
      many: true,
    },
    sentMessages: {
      to: {
        messages: {
          on: { // [!code ++]
            'messages.senderId': 'users.id', // [!code ++]
          }, // [!code ++]
        },
      },
      many: true,
    },
  },
})

interface Message {
  id: string
  content: string
  senderId: string
  recipientId: string
}

const messageModel = defineItemType<Message>().model({
  name: 'messages',
  relations: {
    sender: {
      to: {
        users: {
          on: { // [!code ++]
            'users.id': 'messages.senderId', // [!code ++]
          }, // [!code ++]
        },
      },
    },
    recipient: {
      to: {
        users: {
          on: { // [!code ++]
            'users.id': 'messages.recipientId', // [!code ++]
          }, // [!code ++]
        },
      },
    },
  },
})
```

This new syntax also allows you to map multiple fields on a single relation:

```ts
const myModel = {
  name: 'things',
  relations: {
    relatedItems: {
      to: {
        otherModel: {
          on: {
            'otherModel.type': 'things.relatedItemType', // [!code ++]
            'otherModel.subType': 'things.relatedItemSubType', // [!code ++]
          },
        },
      },
    },
  },
}
```

Or specify a custom filter function:

```ts
const myModel = {
  name: 'things',
  relations: {
    relatedItems: {
      to: {
        otherModel: {
          on: {
            // 'otherModel.type': 'things.relatedItemType',
          },
          filter: (item, relationItem) => // [!code ++]
            item.relatedStatusList.includes(relationItem.status), // [!code ++]
        },
      },
    },
  },
}
```

If you use TypeScript, it is now recommended to use the new `defineRelations` helper to define your relations with proper typing:

```ts
import type { StoreSchema } from '@rstore/vue'
import { defineItemType, defineRelations } from '@rstore/vue'

interface User {
  id: string
  name: string
}

const userModel = defineItemType<User>().model({
  name: 'users',
})

interface Message {
  id: string
  content: string
  senderId: string
  recipientId: string
}

const messageModel = defineItemType<Message>().model({
  name: 'messages',
})

const userRelations = defineRelations(userModel, ({ model }) => ({
  receivedMessages: {
    to: model(messageModel, {
      on: {
        'messages.recipientId': 'users.id', // Type checked!
      },
    }),
    many: true,
  },
  sentMessages: {
    to: model(messageModel, {
      on: {
        'messages.senderId': 'users.id', // Type checked!
      },
    }),
    many: true,
  },
}))

const messageRelations = defineRelations(messageModel, ({ model }) => ({
  sender: {
    to: model(userModel, {
      on: {
        'users.id': 'messages.senderId', // Type checked!
      },
    }),
  },
  recipient: {
    to: model(userModel, {
      on: {
        'users.id': 'messages.recipientId', // Type checked!
      },
    }),
  },
}))

export const schema = [
  userModel,
  messageModel,
  userRelations,
  messageRelations,
] as const satisfies StoreSchema
```

Example of the typechecking in action:

![Typechecking example](./img/relation-typing.png)
