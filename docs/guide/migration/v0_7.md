# 0.6 to 0.7 Migration Guide

## Store constructor changes

### `models` renamed to `schema`

::: info Why this change?
Since it now contains both models and relations (see below) - and maybe other objects in the future, the `models` option has been renamed to `schema`.
:::

::: tip Nuxt Tip
If you are using the Nuxt modules, you don't need to do anything as they have already been updated to use the new option name.
:::

```ts
const store = await createStore({
  models: [ // [!code --]
  schema: [ // [!code ++]
    { name: 'todos' },
    { name: 'users' },
  ],
  plugins: [],
})
```

## Relations

### Relation definitions shape changed

Instead of defining the related fields using `on` and `eq` that were confusing, you now define the related fields using an `on` object that maps the foreign fields to the local fields with the name of the models to make it clearer.

::: info Why this change?
This new syntax is more explicit and easier to understand. It also allows for more complex relations such as mapping multiple fields or using a custom filter function.
:::

```ts
import { defineItemType } from '@rstore/vue'

interface User {
  id: string
  name: string
}

const userModel = defineItemType<User>().model({
  name: 'users',
  relations: {
    receivedMessages: {
      to: {
        messages: {
          on: 'recipientId', // [!code --] Message.recipientId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'messages.recipientId': 'users.id', // [!code ++]
          }, // [!code ++]
        },
      },
      many: true,
    },
    sentMessages: {
      to: {
        messages: {
          on: 'senderId', // [!code --] Message.senderId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'messages.senderId': 'users.id', // [!code ++]
          }, // [!code ++]
        },
      },
      many: true,
    },
  },
})

interface Message {
  id: string
  content: string
  senderId: string
  recipientId: string
}

const messageModel = defineItemType<Message>().model({
  name: 'messages',
  relations: {
    sender: {
      to: {
        users: {
          on: 'senderId', // [!code --] Message.senderId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'users.id': 'messages.senderId', // [!code ++]
          }, // [!code ++]
        },
      },
    },
    recipient: {
      to: {
        users: {
          on: 'recipientId', // [!code --] Message.recipientId
          eq: 'id', // [!code --] User.id
          on: { // [!code ++]
            'users.id': 'messages.recipientId', // [!code ++]
          }, // [!code ++]
        },
      },
    },
  },
})
```

This new syntax also allows you to map multiple fields on a single relation:

```ts
const myModel = {
  name: 'things',
  relations: {
    relatedItems: {
      to: {
        otherModel: {
          on: {
            'otherModel.type': 'things.relatedItemType', // [!code ++]
            'otherModel.subType': 'things.relatedItemSubType', // [!code ++]
          },
        },
      },
    },
  },
}
```

Or specify a custom filter function:

```ts
const myModel = {
  name: 'things',
  relations: {
    relatedItems: {
      to: {
        otherModel: {
          on: {
            // 'otherModel.type': 'things.relatedItemType',
          },
          filter: (item, relationItem) => // [!code ++]
            item.relatedStatusList.includes(relationItem.status), // [!code ++]
        },
      },
    },
  },
}
```

If you use TypeScript, it is now recommended to use the new `defineRelations` helper to define your relations with proper typing:

```ts
import type { StoreSchema } from '@rstore/vue'
import { defineItemType, defineRelations } from '@rstore/vue'

interface User {
  id: string
  name: string
}

const userModel = defineItemType<User>().model({
  name: 'users',
})

interface Message {
  id: string
  content: string
  senderId: string
  recipientId: string
}

const messageModel = defineItemType<Message>().model({
  name: 'messages',
})

const userRelations = defineRelations(userModel, ({ model }) => ({
  receivedMessages: {
    to: model(messageModel, {
      on: {
        'messages.recipientId': 'users.id', // Type checked!
      },
    }),
    many: true,
  },
  sentMessages: {
    to: model(messageModel, {
      on: {
        'messages.senderId': 'users.id', // Type checked!
      },
    }),
    many: true,
  },
}))

const messageRelations = defineRelations(messageModel, ({ model }) => ({
  sender: {
    to: model(userModel, {
      on: {
        'users.id': 'messages.senderId', // Type checked!
      },
    }),
  },
  recipient: {
    to: model(userModel, {
      on: {
        'users.id': 'messages.recipientId', // Type checked!
      },
    }),
  },
}))

export const schema = [
  userModel,
  messageModel,
  userRelations,
  messageRelations,
] as const satisfies StoreSchema
```

Example of the typechecking in action:

![Typechecking example](./img/relation-typing.png)

## Query

### Methods don't accept Ref or getter anymore

The following methods no longer accept a Ref or a getter function as argument. You must now always pass a plain object (or string/number for single key):

- `peekFirst`
- `peekMany`
- `findFirst`
- `findMany`

```ts
store.User.peekFirst(() => 'toto') // [!code --]
store.User.peekFirst('toto') // [!code ++]

store.User.peekFirst(userIdRef) // [!code --]
store.User.peekFirst(userIdRef.value) // [!code ++]
```

::: info Why this change?
This change was made to simplify the API and avoid confusion. Those methods are not reactive and will not update automatically when the Ref or the result of the getter function changes. If you want to use a Ref or a getter function, you can use the `query` or `liveQuery` methods instead.
:::

### New Query API

The following methods have been removed:

- `queryFirst`
- `queryMany`
- `liveQueryFirst`
- `liveQueryMany`

They have been replaced by the following methods:

- `query`
- `liveQuery`

Those two new methods accept a function that receives a query builder as argument. You can then use the `first` or `many` methods of the query builder to build your query.

::: info Why this change?
This new syntax allows TypeScript to fully type check the entire options object, including verifying for excess properties in deeply nested objects. The old syntax was not type checked properly and your code could easily contain typos or mistakes that would not be caught by the compiler. This is due to a limitation in TypeScript (see [microsoft/TypeScript#241](https://github.com/microsoft/TypeScript/issues/241)).
:::

```ts
const { data: user } = await store.User.queryFirst('toto') // [!code --]
const { data: user } = await store.User.query(q => q.first('toto')) // [!code ++]
```

```ts
const { data: user } = await store.User.queryFirst(() => ({ // [!code --]
const { data: user } = await store.User.query(q => q.first({ // [!code ++]
  key: userId.value,
  include: { receivedMessages: true },
}))
```

```ts
const { data: messages } = await store.Message.queryMany(() => ({ // [!code --]
const { data: messages } = await store.Message.query(q => q.many({ // [!code ++]
  filter: m => m.recipientId === userId.value,
}))
```

```ts
const { data: messages } = await store.Message.liveQueryMany(() => ({ // [!code --]
const { data: messages } = await store.Message.liveQuery(q => q.many({ // [!code ++]
  filter: m => m.recipientId === userId.value,
}))
```

::: warning
Since the type checking is now stricter, you might encounter new type errors in your code that you didn't have before. This means that your code was not fully correct and you should fix the errors. If somethig looks wrong, please [open an issue](https://github.com/directus/rstore/issues/new?template=bug-report.yml). :pray:
:::

### Subscribe method now accepts query builder

The `subscribe` method now only accepts a function that receives a query builder as argument. You then have to call the query builder function with the options object.

Before:

Before:

```ts
const { unsubscribe } = store.Message.subscribe({ // [!code --]
const { unsubscribe } = store.Message.subscribe(q => q({ // [!code ++]
  params: {
    recipientId: 'user-123',
  },
}) // [!code --]
})) // [!code ++]
```

```ts
const { unsubscribe } = store.Message.subscribe(() => ({ // [!code --]
const { unsubscribe } = store.Message.subscribe(q => q({ // [!code ++]
  params: {
    recipientId: userId.value,
  },
}))
```

::: info Why this change?
This new syntax allows TypeScript to fully type check the entire options object, including verifying for excess properties in deeply nested objects. The old syntax was not type checked properly and your code could easily contain typos or mistakes that would not be caught by the compiler. This is due to a limitation in TypeScript (see [microsoft/TypeScript#241](https://github.com/microsoft/TypeScript/issues/241)).
:::

::: warning
Since the type checking is now stricter, you might encounter new type errors in your code that you didn't have before. This means that your code was not fully correct and you should fix the errors. If somethig looks wrong, please [open an issue](https://github.com/directus/rstore/issues/new?template=bug-report.yml). :pray:
:::
